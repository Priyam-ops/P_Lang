#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <emscripten.h>

// Output buffer for web
static char output_buffer[10000];
static int output_pos = 0;

// Input handling for web
static char input_value[100] = "";
static int waiting_for_input = 0;
static char pending_var_name[100] = "";

// Clear output buffer
EMSCRIPTEN_KEEPALIVE
void clear_output() {
    output_buffer[0] = '\0';
    output_pos = 0;
}

// Get output buffer
EMSCRIPTEN_KEEPALIVE
const char* get_output() {
    return output_buffer;
}

// Append to output buffer (replaces printf)
void web_print(const char* str) {
    int len = strlen(str);
    if (output_pos + len < sizeof(output_buffer) - 1) {
        strcpy(output_buffer + output_pos, str);
        output_pos += len;
    }
}

void web_print_int(int val) {
    char buf[32];
    sprintf(buf, "%d", val);
    web_print(buf);
}

// ============== Your existing structures ==============
typedef struct Node {
    int data;
    char *text;
    struct Node* next;
    struct Node* prev;
} Node;

typedef struct Variable {
    int value;
    int code;
    char symbol[100];
    struct Variable* next;
} Vr;

// Global variables pointer
static Vr *variables = NULL;

// ============== Your existing functions (with printf replaced) ==============

void assignment(int token, char symbol[100], Vr **variables) {
    Vr *current = *variables;
    while(current != NULL) {   
        if(strcmp(current->symbol, symbol) == 0) {
            current->value = token;
            return;
        }
        current = current->next;
    }
    Vr *new = malloc(sizeof(Vr));
    new->value = token;
    strcpy(new->symbol, symbol);
    new->code = (*variables)->value;
    (*variables)->value--;
    new->next = NULL;

    current = *variables;
    if (current == NULL || current->next == NULL) {
        (*variables)->next = new;
    } else {
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new;
    }
}

void arithmetic(Node** head) {
    Node* current = *head;
    // Division
    while (current) {
        if (current->data == -9) {
            int prev = 0, next = 0;
            if (current->prev && current->prev->data > 0) prev = current->prev->data;
            if (current->next && current->next->data > 0) next = current->next->data;
            if (next == 0) {
                web_print("Division by zero error\n");
                current = current->next;
                continue;
            }
            int sum = prev / next;
            Node *new = malloc(sizeof(Node));
            new->text = NULL;
            new->data = sum;
            new->prev = current->prev->prev;
            new->next = current->next->next;
            if (current->prev->prev) current->prev->prev->next = new;
            if (current->next->next) current->next->next->prev = new;
        }
        current = current->next;
    }
    // Multiplication
    current = *head;
    while (current) {
        if (current->data == -8) {
            int prev = 0, next = 0;
            if (current->prev && current->prev->data > 0) prev = current->prev->data;
            if (current->next && current->next->data > 0) next = current->next->data;
            int sum = prev * next;
            Node *new = malloc(sizeof(Node));
            new->text = NULL;
            new->data = sum;
            new->prev = current->prev->prev;
            new->next = current->next->next;
            if (current->prev->prev) current->prev->prev->next = new;
            if (current->next->next) current->next->next->prev = new;
        }
        current = current->next;
    }
    // Addition
    current = *head;
    while (current) {
        if (current->data == -6) {
            int prev = 0, next = 0;
            if (current->prev && current->prev->data > 0) prev = current->prev->data;
            if (current->next && current->next->data > 0) next = current->next->data;
            int sum = prev + next;
            Node *new = malloc(sizeof(Node));
            new->text = NULL;
            new->data = sum;
            new->prev = current->prev->prev;
            new->next = current->next->next;
            if (current->prev->prev) current->prev->prev->next = new;
            if (current->next->next) current->next->next->prev = new;
        }
        current = current->next;
    }
    // Subtraction
    current = *head;
    while (current) {
        if (current->data == -7) {
            int prev = 0, next = 0;
            if (current->prev && current->prev->data > 0) prev = current->prev->data;
            if (current->next && current->next->data > 0) next = current->next->data;
            int sum = prev - next;
            Node *new = malloc(sizeof(Node));
            new->text = NULL;
            new->data = sum;
            new->prev = current->prev->prev;
            new->next = current->next->next;
            if (current->prev->prev) current->prev->prev->next = new;
            if (current->next->next) current->next->next->prev = new;
        }
        current = current->next;
    }
}

void Bracket_Operator(Node** head) {
    Node *current = *head;
    while (current != NULL) {
        if (current->data == -10) {
            Node *temp = current->next;
            while (temp != NULL && temp->data != -11) { 
                temp = temp->next;
            }
            if (temp == NULL) {
                web_print("Error: Unmatched '(' found.\n");
                return;
            } else {
                Node *pointer = NULL;
                if (temp->next != NULL) {
                    pointer = temp->next;
                    temp->next = NULL;
                }
                arithmetic(&current);
                Node *tail = current;
                while (tail->next != NULL) {
                    tail = tail->next;
                }
                tail->next = pointer;
                current = pointer;
                continue;
            }
        }
        current = current->next;
    }
}

void Logical_Operators(Node** head) {
    // NOT operator
    Node *current = *head;
    while (current) {
        if (current->data == -31 && current->next != NULL) {
            int next_val = 0;
            if (current->next->data == -19) next_val = 1;
            else if (current->next->data == -20) next_val = 0;
            else if (current->next->data > 0) next_val = (current->next->data != 0) ? 1 : 0;
            
            int result_token = ! next_val ?  -19 : -20;
            Node *new = malloc(sizeof(Node));
            new->text = NULL;
            new->data = result_token;
            new->prev = current->prev;
            new->next = current->next->next;
            if (current->prev) current->prev->next = new;
            if (current->next->next) current->next->next->prev = new;
        }
        current = current->next;
    }
    
    // AND operator
    current = *head;
    while (current) {
        if (current->data == -29 && current->prev && current->next) {
            int prev_val = 0, next_val = 0;
            if (current->prev->data == -19) prev_val = 1;
            else if (current->prev->data > 0) prev_val = (current->prev->data != 0) ? 1 : 0;
            if (current->next->data == -19) next_val = 1;
            else if (current->next->data > 0) next_val = (current->next->data != 0) ? 1 : 0;
            
            int result_token = (prev_val && next_val) ? -19 : -20;
            Node *new = malloc(sizeof(Node));
            new->text = NULL;
            new->data = result_token;
            new->prev = current->prev->prev;
            new->next = current->next->next;
            if (current->prev->prev) current->prev->prev->next = new;
            if (current->next->next) current->next->next->prev = new;
        }
        current = current->next;
    }
    
    // OR operator
    current = *head;
    while (current) {
        if (current->data == -30 && current->prev && current->next) {
            int prev_val = 0, next_val = 0;
            if (current->prev->data == -19) prev_val = 1;
            else if (current->prev->data > 0) prev_val = (current->prev->data != 0) ? 1 : 0;
            if (current->next->data == -19) next_val = 1;
            else if (current->next->data > 0) next_val = (current->next->data != 0) ? 1 : 0;
            
            int result_token = (prev_val || next_val) ? -19 : -20;
            Node *new = malloc(sizeof(Node));
            new->text = NULL;
            new->data = result_token;
            new->prev = current->prev->prev;
            new->next = current->next->next;
            if (current->prev->prev) current->prev->prev->next = new;
            if (current->next->next) current->next->next->prev = new;
        }
        current = current->next;
    }
}

void Sundowner(Node** head) {
    Node *current = *head;
    while(current) {
        int stuff = -19;
        int condition_met = 0;
        
        if (current->data == -15 && current->prev && current->next) {
            condition_met = (current->prev->data == current->next->data);
        } else if (current->data == -16 && current->prev && current->next) {
            condition_met = (current->prev->data > current->next->data);
        } else if (current->data == -17 && current->prev && current->next) {
            condition_met = (current->prev->data < current->next->data);
        } else if (current->data == -18 && current->prev && current->next) {
            condition_met = (current->prev->data != current->next->data);
        } else if (current->data == -23 && current->prev && current->next) {
            condition_met = (current->prev->data >= current->next->data);
        } else if (current->data == -22 && current->prev && current->next) {
            condition_met = (current->prev->data <= current->next->data);
        } else {
            current = current->next;
            continue;
        }
        
        stuff = condition_met ? -19 : -20;
        Node *new = malloc(sizeof(Node));
        new->text = NULL;
        new->data = stuff;
        new->prev = current->prev->prev;
        new->next = current->next->next;
        if (current->prev->prev) current->prev->prev->next = new;
        if (current->next->next) current->next->next->prev = new;
        
        current = current->next;
    }
}

int Sam(char *command, Vr **variables) {
    const char *tokens[] = {
        "", "show", "clear", "help", "exit",
        "is", "+", "-", "*", "/", 
        "(", ")", "take", "if", "else",
        "=", ">", "<", "!", "yes", 
        "no", "while", "<=", ">=", "++",
        "--", "until", "endwhile", "enduntil",
        "&", "|", "not"
    };
    int num_tokens = 32;
    char number[] = "0123456789";
    
    // Handle ++ operator
    if (strlen(command) >= 2 && command[strlen(command)-1] == '+' && command[strlen(command)-2] == '+') {
        command[strlen(command)-2] = '\0';
        Vr *current = *variables;
        while (current != NULL && strcmp(command, current->symbol) != 0) {
            current = current->next;
        }
        if (current != NULL) current->value += 1;
    }
    
    // Handle -- operator
    if (strlen(command) >= 2 && command[strlen(command)-1] == '-' && command[strlen(command)-2] == '-') {
        command[strlen(command)-2] = '\0';
        Vr *current = *variables;
        while (current != NULL && strcmp(command, current->symbol) != 0) {
            current = current->next;
        }
        if (current != NULL) current->value -= 1;
    }
    
    // Check for variable
    Vr *current = *variables;
    while (current != NULL) {
        if (strcmp(command, current->symbol) == 0) {
            return current->value;
        }
        current = current->next;
    }
    
    // Check for keyword token
    for (int i = 0; i < num_tokens; i++) {
        if (strcmp(command, tokens[i]) == 0)
            return i * (-1);
    }
    
    // Check for number
    int is_num;
    int c = 0;
    for (int i = 0; i < strlen(command); i++) {
        is_num = 0;
        for (int j = 0; j < strlen(number); j++) {
            if (command[i] == number[j]) {
                is_num = 1;
                c = c * 10 + (command[i] - '0');
                continue;
            }
            if (command[i] == '+') is_num = 1;
        }
        if (! is_num) return -666;
    }
    if (c != 666) return c;
    return 666;
}

Node* Jack(const char *command, Vr **variables) {
    Node *head = NULL, *tail = NULL;
    char token[100];
    char *text;
    char imp_token[100];
    int looking_for_operator = 0;
    int operator = 0;
    int looking_for_operand = 0;
    int assign = 0;
    char last_symbol[100] = "";
    int i = 0, j = 0;
    
    while (1) {
        char c = command[i];
        if (c == ' ' || c == '\0') {
            if (j > 0) {
                text = NULL;
                token[j] = '\0';
                int val = Sam(token, variables);
                
                if (val == -24) {
                    Vr *current = *variables;
                    while (current != NULL && strcmp(current->symbol, last_symbol) != 0) {
                        current = current->next;
                    }
                    if (current != NULL) current->value += 1;
                }
                if (val == -25) {
                    Vr *current = *variables;
                    while (current != NULL && strcmp(current->symbol, last_symbol) != 0) {
                        current = current->next;
                    }
                    if (current != NULL) current->value -= 1;
                }
                
                if (looking_for_operand) {
                    looking_for_operand = 0;
                    looking_for_operator = 0;
                    if (val > 0) {
                        Vr *current = *variables;
                        while (current->next != NULL) current = current->next;
                        if (operator == -6) current->value += val;
                        if (operator == -7) current->value -= val;
                        if (operator == -8) current->value *= val;
                        if (operator == -9 && val != 0) current->value /= val;
                    }
                }
                
                if (looking_for_operator) {
                    looking_for_operator = 0;
                    if (val == -6 || val == -7 || val == -8 || val == -9) {
                        looking_for_operand = 1;
                        operator = val;
                    }
                }
                
                if (val == -5) {
                    strcpy(imp_token, last_symbol);
                    assign = 1;
                }
                
                if (assign && (val > 0 || val == -666)) {
                    assign = 0;
                    looking_for_operator = 1;
                    assignment(val, imp_token, variables);
                }
                
                if (val == -666) {
                    text = strdup(token);
                }
                
                Node *node = malloc(sizeof(Node));
                node->text = text;
                node->data = val;
                node->next = NULL;
                node->prev = tail;

                if (! head) head = node;
                else tail->next = node;
                tail = node;
                
                strcpy(last_symbol, token);
                j = 0;
            }
            if (c == '\0') break;
        } else {
            token[j++] = c;
        }
        i++;
    }
    if (tail) tail->next = NULL;
    return head;
}

int doc(Node** head) {
    if ((*head)->next && (*head)->next->data == -19) {
        return 1;
    }
    return 0;
}

void show_token(Node* head) {
    head = head->next;
    if (! head) return;
    
    if (head->data == -666 && head->text) {
        char output[256];
        strcpy(output, head->text);
        for (int i = 0; output[i] != '\0'; i++) {
            if (output[i] == '_') output[i] = ' ';
        }
        web_print(output);
        web_print("\n");
    } else if (head->data == -19) {
        web_print("yes\n");
    } else if (head->data == -20) {
        web_print("no\n");
    } else {
        web_print_int(head->data);
        web_print("\n");
    }
}

void free_tokens(Node* tokens) {
    while (tokens) {
        Node *n = tokens->next;
        if (tokens->text) free(tokens->text);
        free(tokens);
        tokens = n;
    }
}

// ============== Main WebAssembly Entry Point ==============

EMSCRIPTEN_KEEPALIVE
void init_compiler() {
    if (variables) {
        // Free existing variables
        Vr *current = variables;
        while (current) {
            Vr *next = current->next;
            free(current);
            current = next;
        }
    }
    variables = malloc(sizeof(Vr));
    variables->value = -50;
    variables->next = NULL;
    clear_output();
}

EMSCRIPTEN_KEEPALIVE
const char* run_plang(const char* code) {
    clear_output();
    
    if (!variables) {
        init_compiler();
    }
    
    char *code_copy = strdup(code);
    char *line = strtok(code_copy, "\n");
    
    // Line storage for loops
    char **lines = NULL;
    int line_count = 0;
    int line_capacity = 100;
    lines = malloc(line_capacity * sizeof(char*));
    
    // Store all lines
    char *temp_code = strdup(code);
    char *temp_line = strtok(temp_code, "\n");
    while (temp_line) {
        if (line_count >= line_capacity) {
            line_capacity *= 2;
            lines = realloc(lines, line_capacity * sizeof(char*));
        }
        lines[line_count++] = strdup(temp_line);
        temp_line = strtok(NULL, "\n");
    }
    free(temp_code);
    
    int current_line = 0;
    int in_loop = 0;
    int loop_start = 0;
    int loop_type = 0;
    char loop_condition[300] = "";
    int skip_execution = 0;
    int max_iterations = 10000; // Safety limit
    int iteration_count = 0;
    
    while (current_line < line_count && iteration_count++ < max_iterations) {
        char *buffer = lines[current_line];
        
        Node *tokens = Jack(buffer, &variables);
        if (!tokens) {
            current_line++;
            continue;
        }
        
        Bracket_Operator(&tokens);
        arithmetic(&tokens);
        Sundowner(&tokens);
        Logical_Operators(&tokens);
        
        Node *cur = tokens;
        
        while (cur) {
            if (cur->data <= -1) {
                switch (cur->data) {
                    case -1: // show
                        if (! skip_execution) show_token(cur);
                        cur = cur->next;
                        continue;
                        
                    case -2: // clear
                        if (!skip_execution) clear_output();
                        break;
                        
                    case -3: // help
                        if (!skip_execution) web_print("P_Lang Commands: show, clear, help, exit, if, else, while, until\n");
                        break;
                        
                    case -4: // exit
                        free_tokens(tokens);
                        for (int i = 0; i < line_count; i++) free(lines[i]);
                        free(lines);
                        free(code_copy);
                        return output_buffer;
                        
                    case -13: // if
                        if (doc(&cur)) {
                            skip_execution = 0;
                        } else {
                            skip_execution = 1;
                        }
                        break;
                        
                    case -14: // else
                        skip_execution = 0;
                        break;
                        
                    case -21: // while
                        if (doc(&cur)) {
                            in_loop = 1;
                            loop_type = -21;
                            loop_start = current_line + 1;
                            strcpy(loop_condition, buffer);
                            skip_execution = 0;
                        } else {
                            skip_execution = 1;
                        }
                        break;
                        
                    case -27: // endwhile
                        if (in_loop && loop_type == -21) {
                            Node *cond = Jack(loop_condition, &variables);
                            Bracket_Operator(&cond);
                            arithmetic(&cond);
                            Sundowner(&cond);
                            Logical_Operators(&cond);
                            
                            if (doc(&cond)) {
                                current_line = loop_start - 1;
                            } else {
                                in_loop = 0;
                            }
                            free_tokens(cond);
                        }
                        skip_execution = 0;
                        break;
                        
                    case -26: // until
                        if (! doc(&cur)) {
                            in_loop = 1;
                            loop_type = -26;
                            loop_start = current_line + 1;
                            strcpy(loop_condition, buffer);
                            skip_execution = 0;
                        } else {
                            skip_execution = 1;
                        }
                        break;
                        
                    case -28: // enduntil
                        if (in_loop && loop_type == -26) {
                            Node *cond = Jack(loop_condition, &variables);
                            Bracket_Operator(&cond);
                            arithmetic(&cond);
                            Sundowner(&cond);
                            Logical_Operators(&cond);
                            
                            if (! doc(&cond)) {
                                current_line = loop_start - 1;
                            } else {
                                in_loop = 0;
                            }
                            free_tokens(cond);
                        }
                        skip_execution = 0;
                        break;
                }
            }
            cur = cur->next;
        }
        
        free_tokens(tokens);
        current_line++;
    }
    
    if (iteration_count >= max_iterations) {
        web_print("\n[Warning: Execution stopped - possible infinite loop]\n");
    }
    
    for (int i = 0; i < line_count; i++) free(lines[i]);
    free(lines);
    free(code_copy);
    
    return output_buffer;
}